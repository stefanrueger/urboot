#!/bin/bash

# published under GNU General Public License, version 3 (GPL-3.0)
# author Stefan Rueger <stefan.rueger@urclocks.com>
# 06.11.2022

# Compile bootloaders for one MCU

progname=$(basename $0)

Usage() {
cat <<END
Syntax: $progname [<opt>] <mcu>
Function: create bootloaders for the 8-bit AVR MCU <mcu> (all lower case)
Option:
    -b <dir> directory in which the bootloaders are created (default bootloaders)
    -d       dry run: show which bootloaders would be created
END
}

run=1
bootloaders=bootloaders
here=$(pwd)

while getopts ":db:" opt; do
  case ${opt} in
    b) bootloaders=$OPTARG
        ;;
    d) run=0
        ;;
    --) shift;
        break
        ;;
   \?) echo "Invalid option: $OPTARG" 1>&2
       Usage 1>&2; exit 1
       ;;
   : ) echo "Invalid option: $OPTARG requires an argument" 1>&2
       Usage 1>&2; exit 1
       ;;
  esac
done
shift $((OPTIND -1))

if [ $# != 1 ]; then Usage 1>&2; exit 1; fi

mcu="$1"


####
# Set out for which targets, F_CPUs, baud rates and I/O lines (for SW I/O) to compile
#

####
# Baud rate and F_CPU combinations
#

# Map F_CPU to baud rates: compile for these combinations
# (Some are redundant as 16 MHz @ 115200 baud is the same as 8 MHz @ 57600 baud)
declare -A baud

baud[24000000]=1000000/500000/250000/230400/115200/57600/38400/19200
baud[22118400]=460800/230400/115200/57600/38400/19200
baud[20000000]=500000/250000/115200/19200
baud[18432000]=460800/230400/115200/57600/38400/19200/9600
baud[16000000]=1000000/500000/250000/115200/38400/19200/9600
baud[14745600]=460800/230400/115200/57600/38400/19200/9600
baud[12000000]=500000/250000/115200/57600/19200/9600
baud[11059200]=460800/230400/115200/57600/38400/19200/9600
baud[8000000]=1000000/500000/250000/115200/57600/38400/19200/9600
baud[7372800]=460800/230400/115200/57600/38400/19200/9600
baud[4000000]=500000/250000/19200/9600
baud[3686400]=460800/230400/115200/57600/38400/19200/9600
baud[2000000]=250000/19200/9600
baud[1843200]=230400/115200/57600/38400/19200/9600
baud[1000000]=9600

# Problematic combinations for USART (high baud rate error)
declare -A nousart

nousart[8000000/115200]=1

# Baud rate too fast/slow for SWIO
declare -A noswio

noswio[16000000/1000000]=1
noswio[8000000/1000000]=1
noswio[8000000/500000]=1
noswio[7372800/460800]=1
noswio[4000000/500000]=1
noswio[4000000/250000]=1
noswio[3686400/460800]=1
noswio[3686400/230400]=1
noswio[2000000/250000]=1
noswio[1843200/230400]=1
noswio[1843200/115200]=1

noswio[18432000/9600]=1
noswio[16000000/9600]=1


####
# Known boards
#

# At least generate a template bootloader (with placeholder nops)
board=none:TEMPLATE=1

# Various boards have the LED on different pins, some low active
if [ $mcu = atmega328p ]; then
  board+=/anarduino,moteino:LED=AtmelPB1
  board+=/urclock,timeduino,jeenode:LEDPOLARITY=-1_LED=AtmelPB1
  board+=/urclockusb:LED=AtmelPD5
  board+=/ursense:LEDPOLARITY=-1_LED=AtmelPD5
  board+=/uno,rbbb,promini:LED=AtmelPB5
fi
if [ $mcu = attiny85 ]; then
board+=/digispark:LED=AtmelPB1
fi
if [ $mcu = attiny167 ]; then
board+=/digispark-pro:LED=AtmelPB1
fi
if [ $mcu = attiny84 ]; then
board+=/luminet:LED=AtmelPA4
fi
if [ $mcu = atmega1284p ]; then
board+=/bobuino,mighty1284,wildfire-v2:LED=AtmelPB7
board+=/wildfire:LED=AtmelPB5
board+=/moteinomega:LED=AtmelPD7
board+=/urclockmega:LED=AtmelPC7
fi
if [ $mcu = atmega644p ]; then
board+=/sanguino:LED=AtmelPB0
fi
if [ $mcu = atmega2560 ]; then
board+=/mega-r3:LED=AtmelPB7
fi
if [ $mcu = atmega1280 ]; then
board+=/mega1280:LED=AtmelPB7
fi


####
# I/O pins for MCUs without USART for software I/O
#
declare -A swio

# Generally, we don't know which lines are used by a board for SWIO, but cater for known boards
swio[attiny84]="SWIO=1 RX=AtmelPA3 TX=AtmelPA2"  # Luminet
swio[attiny85]="SWIO=1 RX=AtmelPB4 TX=AtmelPB3"  # Digispark
swio[attiny167]="SWIO=1 RX=AtmelPB6 TX=AtmelPB3" # Digispark Pro

# Unknown I/O: set RX=B0 and TX=B1 but this vvv unlikely what you want!

mcusnousart=(at90pwm1 at90pwm161 at90pwm81 ata5272 ata5505 ata5700m322 ata5702m322 ata5781 \
  ata5782 ata5783 ata5790 ata5790n ata5791 ata5795 ata5831 ata5832 ata5833 ata6285 ata6286 \
  ata6289 ata6616c ata6617c ata664251 ata8210 ata8215 ata8510 ata8515 atmega16hva atmega16hva2 \
  atmega16hvb atmega16hvbrevb atmega16m1 atmega32c1 atmega32hvb atmega32hvbrevb atmega32m1 \
  atmega406 atmega64c1 atmega64hve atmega64hve2 atmega64m1 atmega8hva attiny10 attiny11 attiny12 \
  attiny13 attiny13a attiny15 attiny167 attiny20 attiny24 attiny24a attiny25 attiny26 attiny261 \
  attiny261a attiny28 attiny4 attiny40 attiny43u attiny44 attiny44a attiny45 attiny461 attiny461a \
  attiny48 attiny5 attiny84 attiny84a attiny85 attiny861 attiny861a attiny87 attiny88 attiny9)

for part in ${mcusnousart[@]}; do
  [[ -z ${swio[$part]} ]] && swio[$part]="SWIO=1 RX=AtmelPB0 TX=AtmelPB1"
done


####
# Some intell about parts in general
#

####
# MCUs with known HW bootloader support
#
blmcus=(at90can128 at90can32 at90can64 at90pwm1 at90pwm161 at90pwm2 at90pwm216 at90pwm2b \
  at90pwm3 at90pwm316 at90pwm3b at90pwm81 at90scr100 at90usb1286 at90usb1287 at90usb162 \
  at90usb646 at90usb647 at90usb82 ata5782 ata5790 ata5790n ata5791 ata5795 ata5831 ata6285 \
  ata6286 ata6289 ata6612c ata6613c ata6614q ata8210 ata8510 atmega128 atmega1280 atmega1281 \
  atmega1284 atmega1284p atmega1284rfr2 atmega128a atmega128rfa1 atmega128rfr2 atmega16 \
  atmega1608 atmega1609 atmega161 atmega162 atmega163 atmega164a atmega164p atmega164pa atmega165 \
  atmega165a atmega165p atmega165pa atmega168 atmega168a atmega168p atmega168pa atmega168pb \
  atmega169 atmega169a atmega169p atmega169pa atmega16a atmega16hvb atmega16hvbrevb atmega16m1 \
  atmega16u2 atmega16u4 atmega2560 atmega2561 atmega2564rfr2 atmega256rfr2 atmega32 atmega3208 \
  atmega3209 atmega323 atmega324a atmega324p atmega324pa atmega325 atmega3250 atmega3250a \
  atmega3250p atmega3250pa atmega325a atmega325p atmega325pa atmega328 atmega328p atmega328pb \
  atmega329 atmega3290 atmega3290a atmega3290p atmega3290pa atmega329a atmega329p atmega329pa \
  atmega32a atmega32c1 atmega32hvb atmega32hvbrevb atmega32m1 atmega32u2 atmega32u4 atmega32u6 \
  atmega406 atmega4808 atmega4809 atmega64 atmega640 atmega644 atmega644a atmega644p atmega644pa \
  atmega644rfr2 atmega645 atmega6450 atmega6450a atmega6450p atmega645a atmega645p atmega649 \
  atmega6490 atmega6490a atmega6490p atmega649a atmega649p atmega64a atmega64c1 atmega64hve \
  atmega64hve2 atmega64m1 atmega64rfr2 atmega8 atmega808 atmega809 atmega8515 atmega8535 atmega88 \
  atmega88a atmega88p atmega88pa atmega88pb atmega8a atmega8u2 attiny1604 attiny1606 attiny1607 \
  attiny1614 attiny1616 attiny1617 attiny202 attiny204 attiny212 attiny214 attiny3214 attiny3216 \
  attiny3217 attiny402 attiny404 attiny406 attiny412 attiny414 attiny416 attiny417 attiny804 \
  attiny806 attiny807 attiny814 attiny816 attiny817 attiny828 atxmega128a1 atxmega128a1u \
  atxmega128a3 atxmega128a3u atxmega128a4u atxmega128b1 atxmega128b3 atxmega128c3 atxmega128d3 \
  atxmega128d4 atxmega16a4 atxmega16a4u atxmega16c4 atxmega16d4 atxmega16e5 atxmega192a3 \
  atxmega192a3u atxmega192c3 atxmega192d3 atxmega256a3 atxmega256a3b atxmega256a3bu atxmega256a3u \
  atxmega256c3 atxmega256d3 atxmega32a4 atxmega32a4u atxmega32c3 atxmega32c4 atxmega32d3 \
  atxmega32d4 atxmega32e5 atxmega384c3 atxmega384d3 atxmega64a1 atxmega64a1u atxmega64a3 \
  atxmega64a3u atxmega64a4u atxmega64b1 atxmega64b3 atxmega64c3 atxmega64d3 atxmega64d4 \
  atxmega8e5)

# Set ${hwboot[$part]} iff $part is known to have HW bootloader support
declare -A hwboot
for part in ${blmcus[@]}; do hwboot[$part]=1; done


####
# USART IO pins (many are missing; just those available from ATDFs are here)
#
declare -A usartio

usartio[at90can128]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[at90can32]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[at90can64]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[atmega1280]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega1281]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega1284p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega1284]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega128a]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega128]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega1608]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega1609]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega164a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega164pa]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega164p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega168a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega168pa]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega168pb]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega168p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega168]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega169a]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega169pa]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega169p]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega16a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega16]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega16u2]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[atmega16u4]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[atmega2560]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega2561]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega3208]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega3209]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega324a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega324pa]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega324pb]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega324p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega328pb]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega328p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega328]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega329pa]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega329p]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega329]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega32a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega32]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega32u2]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[atmega32u4]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[atmega4808]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega4809]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega48a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega48pa]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega48pb]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega48p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega48]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega640]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega644a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega644pa]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega644p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega644]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega649a]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega649p]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega649]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega64a]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega64]="SWIO=1 RX=AtmelPE0 TX=AtmelPE1"
usartio[atmega808]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega809]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[atmega88a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega88pa]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega88pb]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega88p]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega88]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega8a]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega8]="SWIO=1 RX=AtmelPD0 TX=AtmelPD1"
usartio[atmega8u2]="SWIO=1 RX=AtmelPD2 TX=AtmelPD3"
usartio[attiny102]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny104]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1604]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1606]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1607]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1614]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1616]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1617]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1624]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1626]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny1627]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny202]="SWIO=1 RX=AtmelPA7 TX=AtmelPA6"
usartio[attiny204]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny212]="SWIO=1 RX=AtmelPA7 TX=AtmelPA6"
usartio[attiny214]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny3216]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny3217]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny3224]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny3226]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny3227]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny402]="SWIO=1 RX=AtmelPA7 TX=AtmelPA6"
usartio[attiny404]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny406]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny412]="SWIO=1 RX=AtmelPA7 TX=AtmelPA6"
usartio[attiny414]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny416auto]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny416]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny417]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny424]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny426]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny427]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny441]="SWIO=1 RX=AtmelPA4 TX=AtmelPA5"
usartio[attiny804]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny806]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny807]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny814]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny816]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny817]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny824]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny826]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny827]="SWIO=1 RX=AtmelPB3 TX=AtmelPB2"
usartio[attiny841]="SWIO=1 RX=AtmelPA4 TX=AtmelPA5"
usartio[atxmega128a1u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128a3u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128a4u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128b1]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128b3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128c3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128d3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega128d4]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega16a4u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega16c4]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega16d4]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega16e5]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega192a3u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega192d3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega256a3bu]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega256a3u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega256c3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega256d3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega32a4u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega32c3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega32c4]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega32d3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega32d4]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega32e5]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega384c3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega384d3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64a1u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64a3u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64a4u]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64b1]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64b3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64c3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64d3]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega64d4]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[atxmega8e5]="SWIO=1 RX=AtmelPC2 TX=AtmelPC3"
usartio[avr128da28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128da32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128da48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128da64]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128db28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128db32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128db48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr128db64]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr16dd14]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr16dd20]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr16dd28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr16dd32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32da28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32da32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32da48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32db28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32db32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32db48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32dd14]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32dd20]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32dd28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr32dd32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64da28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64da32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64da48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64da64]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64db28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64db32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64db48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64db64]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64dd14]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64dd20]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64dd28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64dd32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64ea28]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64ea32]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"
usartio[avr64ea48]="SWIO=1 RX=AtmelPA1 TX=AtmelPA0"


####
# Put human readable F_CPU into variable fcpuname
#
mkfcpuname() {
  local frq=$1;
  if [[ ${#1} > 6 ]]; then
    frq=${1%??????}mhz${1:${#1}-6:6}
    frq=${frq%000}; frq=${frq%00}; frq=${frq%0}
  elif  [[ ${#1} > 3 ]]; then
    frq=${1%???}khz${1:0:${#1}-3}
    frq=${frq%00}; frq=${frq%0}
  fi
  fcpuname=$frq
}

####
# Construct a global variable filename for the basename of the bootloader
#
mkfilename() {
  local cfg=$8; [ "$cfg" = TEMPLATE=1 ] && cfg=_lednop;
  cfg=${cfg/LEDPOLARITY=-1_LED=AtmelP/_led-}; cfg=${cfg/LED=AtmelP/_led+};
  cfg=${cfg/_SFMCS=AtmelP/_cs}; cfg=${cfg,,}
  cfg=${cfg,,}
  local swio=$9; swio=${swio/SWIO=1/};
  swio=${swio/ RX=AtmelP/_rx}; swio=${swio/ TX=AtmelP/_tx}; swio=${swio,,}

  filename=$1_$2_$3bps$swio
  [[ $5 -eq 1 ]] && filename+=_ee
  [[ $7 -eq 0 ]] || filename+=$cfg
  [[ $7 -eq 6 ]] && filename+=_fr
  [[ $7 -eq 7 ]] && filename+=_fr_ce
  [[ $6 -eq 1 ]] && filename+=_ur
  [[ $4 -eq 1 ]] && filename+=_vbl
}


[[ $run == 1 ]] && mkdir -p "$bootloaders/$mcu"
for fcpu in ${!baud[@]}; do
  mkfcpuname $fcpu
  [[ $run == 1 ]] && mkdir -p "$bootloaders/$mcu/fcpu_$fcpuname"
  readarray -d / -t bauds <<<${baud[$fcpu]}
  for b in ${bauds[@]}; do
    io="${swio[$mcu]}"        # Empty when USART is available and used
    # USART experiences too high baud rate error for this F_CPU/baud combo
    if [[ -z "$io" && "${nousart[$fcpu/$b]}" -eq 1 ]]; then
      if [[ -n "${usartio[$mcu]}" ]]; then
        io="${usartio[$mcu]}" # Switch to SWIO instead of using the USART
      else
        continue              # Don't know the IO lines of the USART: bail
      fi
    fi
    # SWIO cannot deal with certain F_CPU/baud rate combos
    if [[ -n "$io" && "${noswio[$fcpu/$b]}" -eq 1 ]]; then
      continue
    fi
    dir="$bootloaders/$mcu/fcpu_$fcpuname/${b}_bps"
    [[ $run == 1 ]] && mkdir -p "$dir"
    for ur in 0 1; do
      readarray -d / -t brd <<<$board
      for f in 0 1 6 7; do
        for ee in 0 1; do
          if [[ $ee -eq 0 && $f -gt 1 ]]; then
            continue;
          fi
          for bb in ${brd[@]}; do
            bcfg=${bb#*:}; bname=${bb%:*}
            for vbl in 0 1; do
              # Some MCUs don't have HW boot setcions (vbl=0): don't generate these bl
              if [[ $vbl -eq 0 && ${hwboot[$mcu]} -ne 1 ]]; then
                continue;
              fi
              mkfilename $mcu $fcpuname $b $vbl $ee $ur $f "$bcfg" "$io"
              [[ $run == 1 ]] && make MCU=$mcu F_CPU=${fcpu}L BAUD_RATE=$b $io VBL=$vbl EEPROM=$ee ${bcfg/_/ } URPROTOCOL=$ur FRILLS=$f MOVETO=$filename >& $filename.out
              [[ $run == 1 ]] && mv $filename.{hex,out,elf,lst} "$dir/"
              [[ $run == 0 ]] && echo "$dir/$filename.hex"
            done
            if [[ $f -eq 0 ]]; then
              break
            fi
          done
        done
      done
    done
    [[ $run == 1 ]] && cd "$dir"
    [[ $run == 1 ]] && "$here/hexls" -sort -md "https://raw.githubusercontent.com/stefanrueger/urboot/main/$dir" *.hex >README.md
    [[ $run == 1 ]] && cd "$here"
  done
done
