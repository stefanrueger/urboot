#!/usr/bin/perl -CS

# urboot-gcc
#
# Compiles urboot with the right start address, end address and pgm_write_page() jump.
# Could probably be done with a suitable linker script - but there you go.
#
# published under GNU General Public License, version 3 (GPL-3.0)
# author Stefan Rueger
#
# v 1.2
# 17.11.2022 (first version 09.07.2016)

use strict;
use warnings;
use Cwd qw(abs_path);
use File::Basename;
use Capture::Tiny ':all';

my $progname = basename($0);

# default toolchain locations for different versions
# my $thisdir = dirname(abs_path($0)).'/avr-toolchain';
my $thisdir = './avr-toolchain';

my $Usage = <<"END_USAGE";
Syntax: $progname [-toolchain=<v>] {avr-gcc opts} urboot.c
Function: compiles urboot with the right addresses until compilation converges
Option:
  -toolchain=<v> uses $thisdir/<v>/bin
                 or avr-gcc version in \$PATH on -toolchain=system or -toolchain=
                 or GCCROOT environment variable
                 or $thisdir/4.8.1/bin
                 (show available list with -toolchain=?)

$progname is an avr-gcc wrapper for urboot bootloader compilation; it computes the correct start
address for the bootloader and the correct rjmp opcode to the pgm_write_page(sram, flash) function
in the bootloader and injects both as -DSTART=<addr> and -DRJMPWP=<opcode>, respectively, when
calling avr-gcc.

Finding the right address for the bootloader is a two-step, sometimes three-step process: On first
compilation a START address is used that works with the target mcu, but will be too low. Once the
bootloader is complied and linked, $progname compiles again using size info and urboot version bits
from the newly created .elf file. The bootloader placement depends on the type of bootloader
support that the mcu offers, and on whether the bootloader is a vector bootloader (VBL - as encoded
in the version bits), which requires no bootloader support by the mcu. For example, you might have
compiled a bootloader for the ATmega1284P with VBL support that fits into 512 bytes. This will be
placed in the topmost 512 bytes of the flash space. However, if compiled as normal bootloader
without VBL support, it must be placed in the top 1024 bytes, because that's the smallest boot
section that this mcu offers. $progname aligns the bootloader with the correct SPM page size and/or
boot section size. In a slight complication of things, it may happen that the size of the
bootloader changes after the second step. This is because the bootloader address is used as
compile-time constant, which when changed, can be used in a different way by the code or optimiser.
This is normally not a problem, but when the new size ticks over the boot section or page size
limit, this will trigger a linker error after the second step. To resolve this, $progname must
compile and link a third time, this time adding a few bytes of slack to the size. In case you
requested the export of pgm_write_page() in the bootloader source, $progname computes the
appropriate 2-byte rjmp call and places it 4 bytes under the end of the bootloader, ie, at the end
of flash just before the two version bytes.

In addition to figuring out the correct start address of the bootloader and the correct rjmp to the
pgm_write_page(sram, flash) bootloader routine, $progname also runs avr-gcc one more final time
with -D_urboot_AVAILABLE=<num_bytes> to indicate how many free bytes are available for desirable,
but not essential features. Currently, urboot.c uses this feature for the generation of reset
vector protection code for vector bootloaders.
END_USAGE

# 4.8.1 produces tight code
my $avrbins = './avr-toolchain/4.8.1/bin';

# did the first option specify the toolchain?
if(@ARGV+0 > 0 && $ARGV[0] =~ /^-toolchain=/) {
  my ($tooldir, $tcversion) = ($thisdir, 481);

  ($tcversion = $ARGV[0]) =~ s/^-toolchain=//;
  $tcversion = getnum($tcversion);
  shift;

  die "$progname: missing the directory $tooldir for avr toolchain\n" if ! -d $tooldir;
  my %versions = map { getnum($_) => $_ } map { basename($_) } glob( $tooldir . '/*' );

  if(!length($tcversion) || $tcversion eq 'system') {
    # no directory specified, use system installed compiler
    $avrbins = '';
  } elsif(!exists $versions{$tcversion} || $tcversion eq '0' || $tcversion eq '?') {
    print("$progname: unknown version $tcversion; available versions:\n") unless $tcversion eq '0' || $tcversion eq '?';
    print("$_ -> $versions{$_}\n") for sort keys %versions;
    exit(0);
  } else {
    $avrbins = "$tooldir/$versions{$tcversion}/bin";
  }
} elsif(exists $ENV{GCCROOT} && length $ENV{GCCROOT}) {
  $avrbins = $ENV{GCCROOT};
}

# ensure a trailing slash if we have a directory for the avr bins
if(length($avrbins)) {
  $avrbins =~ s/\/*$/\//;
  die "$progname: unknown avr bin directory $avrbins\n" if length($avrbins) && !-d $avrbins;
}

# print "@ARGV\n";

use constant {
# version capabilities
  UR_VBLMASK => 0x0C,       # mask for vector boot loader
  UR_PGMWRITEPAGE   => 128, # pgm_write_page() subroutine that can be called from application at FLASHEND+1-4
# _features bits of table below
  F_ERRATA_SKIP_JMP_CALL => 0x00001,
  F_ERRATA_SKIP          => 0x00002,
  F_ENHANCED             => 0x00004,
  F_3_BYTE_PC            => 0x00008,
  F_HAVE_MOVW            => 0x00010,
  F_HAVE_MUL             => 0x00020,
  F_HAVE_LPMX            => 0x00040,
  F_HAVE_ELPMX           => 0x00080,
  F_HAVE_ELPM            => 0x00100,
  F_HAVE_JMP_CALL        => 0x00200,
  F_ISA_RMW              => 0x00400,
  F_HAVE_EIJMP_EICALL    => 0x00800,
  F_HAVE_RAMPD           => 0x01000,
  F_HAVE_RAMPX           => 0x02000,
  F_HAVE_RAMPY           => 0x04000,
  F_HAVE_RAMPZ           => 0x08000,
  F_MEGA                 => 0x10000,
  F_TINY                 => 0x20000,
  F_XMEGA                => 0x40000,
  F_ASM_ONLY             => 0x80000,
# indices in table below
  _sig0 => 0, _sig1 => 1, _sig2 => 2,
  _archnum => 3, _features => 4,
  _flashstart => 5, _flashsz => 6, _pagesz => 7,
  _nboots => 8, _bootsz => 9,
  _eepromstart => 10, _eepromsz => 11,
  _nisr => 12,
};

# This table comes from urboot-gcc-table.pl (created by mkavrintel.pl); -1 means unknown
my %uP = (
  'attiny4' =>         [0x1E, 0x8F, 0x0A, 100, 0x20000,       0, 0x00200, 0x010,  0,      0,       0,      0,  10],
  'attiny5' =>         [0x1E, 0x8F, 0x09, 100, 0x20000,       0, 0x00200, 0x010,  0,      0,       0,      0,  11],
  'attiny9' =>         [0x1E, 0x90, 0x08, 100, 0x20000,       0, 0x00400, 0x010,  0,      0,       0,      0,  10],
  'attiny10' =>        [0x1E, 0x90, 0x03, 100, 0x20000,       0, 0x00400, 0x010,  0,      0,       0,      0,  11],
  'attiny20' =>        [0x1E, 0x91, 0x0F, 100, 0x20000,       0, 0x00800, 0x020,  0,      0,       0,      0,  17],
  'attiny40' =>        [0x1E, 0x92, 0x0E, 100, 0x20000,       0, 0x01000, 0x040,  0,      0,       0,      0,  18],
  'attiny11' =>        [0x1E, 0x90, 0x04,   1, 0x80000,       0, 0x00400, 0x001,  0,      0,       0, 0x0040,   5],
  'attiny12' =>        [0x1E, 0x90, 0x05,   1, 0x80000,       0, 0x00400, 0x001,  0,      0,       0, 0x0040,   6],
  'attiny13' =>        [0x1E, 0x90, 0x07,  25, 0x00050,       0, 0x00400, 0x020,  0,      0,       0, 0x0040,  10],
  'attiny13a' =>       [0x1E, 0x90, 0x07,  25, 0x00050,       0, 0x00400, 0x020,  0,      0,       0, 0x0040,  10],
  'attiny15' =>        [0x1E, 0x90, 0x06,   1, 0x80000,       0, 0x00400, 0x001,  0,      0,       0, 0x0040,   9],
  'attiny22' =>        [0x1E, 0x91, 0x06,   2,       0,       0, 0x00800,    -1, -1,     -1,      -1,     -1,   3],
  'attiny24' =>        [0x1E, 0x91, 0x0B,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  17],
  'attiny24a' =>       [0x1E, 0x91, 0x0B,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  17],
  'attiny25' =>        [0x1E, 0x91, 0x08,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  15],
  'attiny26' =>        [0x1E, 0x91, 0x09,   2,       0,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  12],
  'attiny28' =>        [0x1E, 0x91, 0x07,   1, 0x80000,       0, 0x00800, 0x002,  0,      0,       0,      0,   6],
  'attiny43u' =>       [0x1E, 0x92, 0x0C,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0040,  16],
  'attiny44' =>        [0x1E, 0x92, 0x07,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  17],
  'attiny44a' =>       [0x1E, 0x92, 0x07,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  17],
  'attiny45' =>        [0x1E, 0x92, 0x06,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  15],
  'attiny48' =>        [0x1E, 0x92, 0x09,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0040,  20],
  'attiny84' =>        [0x1E, 0x93, 0x0C,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0200,  17],
  'attiny84a' =>       [0x1E, 0x93, 0x0C,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0200,  17],
  'attiny85' =>        [0x1E, 0x93, 0x0B,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0200,  15],
  'attiny87' =>        [0x1E, 0x93, 0x87,  25, 0x00050,       0, 0x02000, 0x080,  0,      0,       0, 0x0200,  20],
  'attiny88' =>        [0x1E, 0x93, 0x11,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0040,  20],
  'attiny167' =>       [0x1E, 0x94, 0x87,  35, 0x10250,       0, 0x04000, 0x080,  0,      0,       0, 0x0200,  20],
  'attiny261' =>       [0x1E, 0x91, 0x0C,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  19],
  'attiny261a' =>      [0x1E, 0x91, 0x0C,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  19],
  'attiny441' =>       [0x1E, 0x92, 0x15,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  30], # 4-page erase
  'attiny461' =>       [0x1E, 0x92, 0x08,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  19],
  'attiny461a' =>      [0x1E, 0x92, 0x08,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  19],
  'attiny828' =>       [0x1E, 0x93, 0x14,  25, 0x00050,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0100,  26],
  'attiny841' =>       [0x1E, 0x93, 0x15,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0200,  30], # 4-page erase
  'attiny861' =>       [0x1E, 0x93, 0x0D,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0200,  19],
  'attiny861a' =>      [0x1E, 0x93, 0x0D,  25, 0x00050,       0, 0x02000, 0x040,  0,      0,       0, 0x0200,  19],
  'attiny1634' =>      [0x1E, 0x94, 0x12,  35, 0x10250,       0, 0x04000, 0x080,  0,      0,       0, 0x0100,  28], # 4-page erase
  'attiny2313' =>      [0x1E, 0x91, 0x0A,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  19],
  'attiny2313a' =>     [0x1E, 0x91, 0x0A,  25, 0x00050,       0, 0x00800, 0x020,  0,      0,       0, 0x0080,  21],
  'attiny4313' =>      [0x1E, 0x92, 0x0D,  25, 0x00050,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  21],
  'atmega8' =>         [0x1E, 0x93, 0x07,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  19],
  'atmega8a' =>        [0x1E, 0x93, 0x07,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  19],
  'atmega8hva' =>      [0x1E, 0x93, 0x10,   4, 0x00074,       0, 0x02000, 0x080,  0,      0,       0, 0x0100,  21],
  'atmega8u2' =>       [0x1E, 0x93, 0x89,  35, 0x10250,       0, 0x02000, 0x080,  4, 0x0200,       0, 0x0200,  29],
  'atmega16' =>        [0x1E, 0x94, 0x03,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  21],
  'atmega16a' =>       [0x1E, 0x94, 0x03,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  21],
  'atmega16hva' =>     [0x1E, 0x94, 0x0C,   5, 0x10274,       0, 0x04000, 0x080,  0,      0,       0, 0x0100,  21],
  'atmega16hvb' =>     [0x1E, 0x94, 0x0D,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  29],
  'atmega16hvbrevb' => [0x1E, 0x94, 0x0D,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  29],
  'atmega16m1' =>      [0x1E, 0x94, 0x84,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  31],
  'atmega16hva2' =>    [0x1E, 0x94, 0x0E,   5, 0x10274,       0, 0x04000, 0x080, -1,     -1,      -1,     -1,  22],
  'atmega16u2' =>      [0x1E, 0x94, 0x89,  35, 0x10250,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  29],
  'atmega16u4' =>      [0x1E, 0x94, 0x88,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  43],
  'atmega32' =>        [0x1E, 0x95, 0x02,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  21],
  'atmega32a' =>       [0x1E, 0x95, 0x02,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  21],
  'atmega32hvb' =>     [0x1E, 0x95, 0x10,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  29],
  'atmega32hvbrevb' => [0x1E, 0x95, 0x10,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  29],
  'atmega32c1' =>      [0x1E, 0x95, 0x86,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  31],
  'atmega32m1' =>      [0x1E, 0x95, 0x84,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  31],
  'atmega32u2' =>      [0x1E, 0x95, 0x8A,  35, 0x10250,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  29],
  'atmega32u4' =>      [0x1E, 0x95, 0x87,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  43],
  'atmega32u6' =>      [0x1E, 0x95, 0x88,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,      -1,     -1,  38],
  'atmega48' =>        [0x1E, 0x92, 0x05,   4, 0x00074,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  26],
  'atmega48a' =>       [0x1E, 0x92, 0x05,   4, 0x00074,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  26],
  'atmega48p' =>       [0x1E, 0x92, 0x0A,   4, 0x00074,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  26],
  'atmega48pa' =>      [0x1E, 0x92, 0x0A,   4, 0x00074,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  26],
  'atmega48pb' =>      [0x1E, 0x92, 0x10,   4, 0x00074,       0, 0x01000, 0x040,  0,      0,       0, 0x0100,  27],
  'atmega64' =>        [0x1E, 0x96, 0x02,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  35],
  'atmega64a' =>       [0x1E, 0x96, 0x02,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  35],
  'atmega64hve' =>     [0x1E, 0x96, 0x10,   5, 0x10274,       0, 0x10000, 0x080,  4, 0x0400,      -1,     -1,  25],
  'atmega64c1' =>      [0x1E, 0x96, 0x86,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  31],
  'atmega64m1' =>      [0x1E, 0x96, 0x84,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  31],
  'atmega64hve2' =>    [0x1E, 0x96, 0x10,   5, 0x10274,       0, 0x10000, 0x080,  4, 0x0400,       0, 0x0400,  25],
  'atmega64rfr2' =>    [0x1E, 0xA6, 0x02,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  77],
  'atmega88' =>        [0x1E, 0x93, 0x0A,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  26],
  'atmega88a' =>       [0x1E, 0x93, 0x0A,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  26],
  'atmega88p' =>       [0x1E, 0x93, 0x0F,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  26],
  'atmega88pa' =>      [0x1E, 0x93, 0x0F,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  26],
  'atmega88pb' =>      [0x1E, 0x93, 0x16,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  27],
  'atmega103' =>       [0x1E, 0x97, 0x01,  31, 0x18303,       0, 0x20000, 0x100, -1,     -1,       0, 0x1000,  24],
  'atmega128' =>       [0x1E, 0x97, 0x02,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  35],
  'atmega128a' =>      [0x1E, 0x97, 0x02,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  35],
  'atmega128rfa1' =>   [0x1E, 0xA7, 0x01,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  72],
  'atmega128rfr2' =>   [0x1E, 0xA7, 0x02,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  77],
  'atmega161' =>       [0x1E, 0x94, 0x01,   5, 0x10274,       0, 0x04000, 0x080,  1, 0x0400,       0, 0x0200,  21],
  'atmega162' =>       [0x1E, 0x94, 0x04,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  28],
  'atmega163' =>       [0x1E, 0x94, 0x02,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  18],
  'atmega164a' =>      [0x1E, 0x94, 0x0F,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  31],
  'atmega164p' =>      [0x1E, 0x94, 0x0A,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  31],
  'atmega164pa' =>     [0x1E, 0x94, 0x0A,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  31],
  'atmega165' =>       [0x1E, 0x94, 0x10,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  22],
  'atmega165a' =>      [0x1E, 0x94, 0x10,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  22],
  'atmega165p' =>      [0x1E, 0x94, 0x07,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  22],
  'atmega165pa' =>     [0x1E, 0x94, 0x07,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  22],
  'atmega168' =>       [0x1E, 0x94, 0x06,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  26],
  'atmega168a' =>      [0x1E, 0x94, 0x06,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  26],
  'atmega168p' =>      [0x1E, 0x94, 0x0B,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  26],
  'atmega168pa' =>     [0x1E, 0x94, 0x0B,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  26],
  'atmega168pb' =>     [0x1E, 0x94, 0x15,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  27],
  'atmega169' =>       [0x1E, 0x94, 0x05,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  23],
  'atmega169a' =>      [0x1E, 0x94, 0x11,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  23],
  'atmega169p' =>      [0x1E, 0x94, 0x05,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  23],
  'atmega169pa' =>     [0x1E, 0x94, 0x05,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  23],
  'atmega256rfr2' =>   [0x1E, 0xA8, 0x02,   6, 0x18bfc,       0, 0x40000, 0x100,  4, 0x0400,       0, 0x2000,  77],
  'atmega323' =>       [0x1E, 0x95, 0x01,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,      -1,     -1,  21],
  'atmega324a' =>      [0x1E, 0x95, 0x15,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  31],
  'atmega324p' =>      [0x1E, 0x95, 0x08,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  31],
  'atmega324pa' =>     [0x1E, 0x95, 0x11,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  31],
  'atmega325' =>       [0x1E, 0x95, 0x05,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  22],
  'atmega325a' =>      [0x1E, 0x95, 0x05,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  22],
  'atmega325p' =>      [0x1E, 0x95, 0x0D,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  22],
  'atmega325pa' =>     [0x1E, 0x95, 0x0D,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  22],
  'atmega328' =>       [0x1E, 0x95, 0x14,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  26],
  'atmega328p' =>      [0x1E, 0x95, 0x0F,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  26],
  'atmega328pb' =>     [0x1E, 0x95, 0x16,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  45],
  'atmega329' =>       [0x1E, 0x95, 0x03,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  23],
  'atmega329a' =>      [0x1E, 0x95, 0x03,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  23],
  'atmega329p' =>      [0x1E, 0x95, 0x0B,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  23],
  'atmega329pa' =>     [0x1E, 0x95, 0x0B,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  23],
  'atmega406' =>       [0x1E, 0x95, 0x07,   5, 0x10274,       0, 0x0a000, 0x080,  4, 0x0200,       0, 0x0200,  23],
  'atmega640' =>       [0x1E, 0x96, 0x08,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x1000,  57],
  'atmega644' =>       [0x1E, 0x96, 0x09,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  28],
  'atmega644a' =>      [0x1E, 0x96, 0x09,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  31],
  'atmega644p' =>      [0x1E, 0x96, 0x0A,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  31],
  'atmega644pa' =>     [0x1E, 0x96, 0x0A,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  31],
  'atmega644rfr2' =>   [0x1E, 0xA6, 0x03,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  77],
  'atmega645' =>       [0x1E, 0x96, 0x05,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  22],
  'atmega645a' =>      [0x1E, 0x96, 0x05,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  22],
  'atmega645p' =>      [0x1E, 0x96, 0x0D,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  22],
  'atmega649' =>       [0x1E, 0x96, 0x03,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  23],
  'atmega649a' =>      [0x1E, 0x96, 0x03,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  23],
  'atmega649p' =>      [0x1E, 0x96, 0x0B,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  23],
  'atmega1280' =>      [0x1E, 0x97, 0x03,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  57],
  'atmega1281' =>      [0x1E, 0x97, 0x04,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  57],
  'atmega1284' =>      [0x1E, 0x97, 0x06,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  35],
  'atmega1284p' =>     [0x1E, 0x97, 0x05,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  35],
  'atmega1284rfr2' =>  [0x1E, 0xA7, 0x03,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  77],
  'atmega2560' =>      [0x1E, 0x98, 0x01,   6, 0x18bfc,       0, 0x40000, 0x100,  4, 0x0400,       0, 0x1000,  57],
  'atmega2561' =>      [0x1E, 0x98, 0x02,   6, 0x18bfc,       0, 0x40000, 0x100,  4, 0x0400,       0, 0x1000,  57],
  'atmega2564rfr2' =>  [0x1E, 0xA8, 0x03,   6, 0x18bfc,       0, 0x40000, 0x100,  4, 0x0400,       0, 0x2000,  77],
  'atmega3250' =>      [0x1E, 0x95, 0x06,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3250a' =>     [0x1E, 0x95, 0x06,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3250p' =>     [0x1E, 0x95, 0x0E,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3250pa' =>    [0x1E, 0x95, 0x0E,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3290' =>      [0x1E, 0x95, 0x04,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3290a' =>     [0x1E, 0x95, 0x04,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3290p' =>     [0x1E, 0x95, 0x0C,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega3290pa' =>    [0x1E, 0x95, 0x0C,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  25],
  'atmega6450' =>      [0x1E, 0x96, 0x06,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  25],
  'atmega6450a' =>     [0x1E, 0x96, 0x06,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  25],
  'atmega6450p' =>     [0x1E, 0x96, 0x0E,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  25],
  'atmega6490' =>      [0x1E, 0x96, 0x04,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  25],
  'atmega6490a' =>     [0x1E, 0x96, 0x04,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  25],
  'atmega6490p' =>     [0x1E, 0x96, 0x0C,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  25],
  'atmega8515' =>      [0x1E, 0x93, 0x06,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  17],
  'atmega8535' =>      [0x1E, 0x93, 0x08,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  21],
  'at43usb320' =>      [  -1,   -1,   -1,  31, 0x18300,       0, 0x10000,    -1, -1,     -1,      -1,     -1,   0],
  'at43usb355' =>      [  -1,   -1,   -1,   3, 0x10200,       0, 0x06000,    -1, -1,     -1,      -1,     -1,   0],
  'at76c711' =>        [  -1,   -1,   -1,   3, 0x10200,       0, 0x04000,    -1, -1,     -1,      -1,     -1,   0],
  'at86rf401' =>       [0x1E, 0x91, 0x81,  25, 0x00050,       0, 0x00800,    -1, -1,     -1,      -1,     -1,   3],
  'at90pwm1' =>        [0x1E, 0x93, 0x83,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  32],
  'at90pwm2' =>        [0x1E, 0x93, 0x81,   4, 0x00074,       0, 0x02000, 0x040,  4,     -1,       0, 0x0200,  32],
  'at90pwm2b' =>       [0x1E, 0x93, 0x83,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  32],
  'at90pwm3' =>        [0x1E, 0x93, 0x81,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  32],
  'at90pwm3b' =>       [0x1E, 0x93, 0x83,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  32],
  'at90can32' =>       [0x1E, 0x95, 0x81,   5, 0x10274,       0, 0x08000, 0x100,  4, 0x0400,       0, 0x0400,  37],
  'at90can64' =>       [0x1E, 0x96, 0x81,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  37],
  'at90pwm81' =>       [0x1E, 0x93, 0x88,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  20],
  'at90usb82' =>       [0x1E, 0x93, 0x82,  35, 0x10250,       0, 0x02000, 0x080,  4, 0x0200,       0, 0x0200,  29],
  'at90scr100' =>      [0x1E, 0x96, 0xC1,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0200,      -1,     -1,  38],
  'at90can128' =>      [0x1E, 0x97, 0x81,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  37],
  'at90pwm161' =>      [0x1E, 0x94, 0x8B,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  20],
  'at90usb162' =>      [0x1E, 0x94, 0x82,  35, 0x10250,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  29],
  'at90pwm216' =>      [0x1E, 0x94, 0x83,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  32],
  'at90pwm316' =>      [0x1E, 0x94, 0x83,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0200,       0, 0x0200,  32],
  'at90usb646' =>      [0x1E, 0x96, 0x82,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  38],
  'at90usb647' =>      [0x1E, 0x96, 0x82,   5, 0x10274,       0, 0x10000, 0x100,  4, 0x0400,       0, 0x0800,  38],
  'at90s1200' =>       [0x1E, 0x90, 0x01,   1, 0x80000,       0, 0x00400, 0x001, -1,     -1,       0, 0x0040,   4],
  'at90usb1286' =>     [0x1E, 0x97, 0x82,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  38],
  'at90usb1287' =>     [0x1E, 0x97, 0x82,  51, 0x183f4,       0, 0x20000, 0x100,  4, 0x0400,       0, 0x1000,  38],
  'at90s2313' =>       [0x1E, 0x91, 0x01,   2,       0,       0, 0x00800, 0x001, -1,     -1,       0, 0x0080,  11],
  'at90s2323' =>       [0x1E, 0x91, 0x02,   2,       0,       0, 0x00800,    -1, -1,     -1,      -1,     -1,   3],
  'at90s2333' =>       [0x1E, 0x91, 0x05,   2,       0,       0, 0x00800, 0x001, -1,     -1,       0, 0x0080,  14],
  'at90s2343' =>       [0x1E, 0x91, 0x03,   2,       0,       0, 0x00800, 0x001, -1,     -1,       0, 0x0080,   3],
  'at90s4414' =>       [0x1E, 0x92, 0x01,   2,       0,       0, 0x01000, 0x001, -1,     -1,       0, 0x0100,  13],
  'at90s4433' =>       [0x1E, 0x92, 0x03,   2,       0,       0, 0x01000, 0x001, -1,     -1,       0, 0x0100,  14],
  'at90s4434' =>       [0x1E, 0x92, 0x02,   2,       0,       0, 0x01000, 0x001, -1,     -1,       0, 0x0100,  17],
  'at90s8515' =>       [0x1E, 0x93, 0x01,   2, 0x00002,       0, 0x02000, 0x001, -1,     -1,       0, 0x0200,  13],
  'at90c8534' =>       [  -1,   -1,   -1,   2,       0,       0, 0x02000,    -1, -1,     -1,      -1,     -1,   0],
  'at90s8535' =>       [0x1E, 0x93, 0x03,   2,       0,       0, 0x02000, 0x001, -1,     -1,       0, 0x0200,  17],
  'at94k' =>           [  -1,   -1,   -1,   5, 0x10274,       0, 0x08000,    -1, -1,     -1,      -1,     -1,   0],
  'ata5272' =>         [0x1E, 0x93, 0x87,  25, 0x00050,       0, 0x02000, 0x080,  0,      0,       0, 0x0200,  37],
  'ata5505' =>         [0x1E, 0x94, 0x87,  35, 0x10250,       0, 0x04000, 0x080,  0,      0,       0, 0x0200,  20],
  'ata5702m322' =>     [0x1E, 0x95, 0x69,   5, 0x10274, 0x08000, 0x08000, 0x040,  0,      0,       0, 0x0880,  51],
  'ata5782' =>         [0x1E, 0x95, 0x65,   5, 0x10274, 0x08000, 0x05000, 0x040,  1, 0x5000,       0, 0x0400,  42],
  'ata5790' =>         [0x1E, 0x94, 0x61,   5, 0x10274,       0, 0x04000, 0x080,  1, 0x0800,       0, 0x0800,  30],
  'ata5790n' =>        [0x1E, 0x94, 0x62,   5, 0x10274,       0, 0x04000, 0x080,  1, 0x0800,       0, 0x0800,  31],
  'ata5791' =>         [0x1E, 0x94, 0x62,   5, 0x10274,       0, 0x04000, 0x080,  1, 0x0800,       0, 0x0800,  31],
  'ata5795' =>         [0x1E, 0x93, 0x61,   5, 0x10274,       0, 0x02000, 0x040,  1, 0x0800,       0, 0x0800,  23],
  'ata5831' =>         [0x1E, 0x95, 0x61,   5, 0x10274, 0x08000, 0x05000, 0x040,  1, 0x5000,       0, 0x0400,  42],
  'ata6285' =>         [0x1E, 0x93, 0x82,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0140,  27],
  'ata6286' =>         [0x1E, 0x93, 0x82,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0140,  27],
  'ata6289' =>         [0x1E, 0x93, 0x82,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,      -1,     -1,  27],
  'ata6612c' =>        [0x1E, 0x93, 0x0A,   4, 0x00074,       0, 0x02000, 0x040,  4, 0x0100,       0, 0x0200,  26],
  'ata6613c' =>        [0x1E, 0x94, 0x06,   5, 0x10274,       0, 0x04000, 0x080,  4, 0x0100,       0, 0x0200,  26],
  'ata6614q' =>        [0x1E, 0x95, 0x0F,   5, 0x10274,       0, 0x08000, 0x080,  4, 0x0200,       0, 0x0400,  26],
  'ata6616c' =>        [0x1E, 0x93, 0x87,  25, 0x00050,       0, 0x02000, 0x080,  0,      0,       0, 0x0200,  20],
  'ata6617c' =>        [0x1E, 0x94, 0x87,  35, 0x10250,       0, 0x04000, 0x080,  0,      0,       0, 0x0200,  20],
  'ata8210' =>         [0x1E, 0x95, 0x65,   5, 0x10274, 0x08000, 0x05000, 0x040,  1, 0x5000,       0, 0x0400,  42],
  'ata8510' =>         [0x1E, 0x95, 0x61,   5, 0x10274, 0x08000, 0x05000, 0x040,  1, 0x5000,       0, 0x0400,  42],
  'ata664251' =>       [0x1E, 0x94, 0x87,  35, 0x10250,       0, 0x04000, 0x080,  0,      0,       0, 0x0200,  20],
  'm3000' =>           [  -1,   -1,   -1,   5, 0x10274,       0, 0x10000,    -1, -1,     -1,      -1,     -1,   0],
  'atxmega8e5' =>      [0x1E, 0x93, 0x41, 102, 0x50274,       0, 0x02800, 0x080,  1, 0x0800,       0, 0x0200,  43],
  'atxmega16a4' =>     [0x1E, 0x94, 0x41, 102, 0x50274,       0, 0x05000, 0x100,  1, 0x1000,       0, 0x0400,  94],
  'atxmega16a4u' =>    [0x1E, 0x94, 0x41, 102, 0x50674,       0, 0x05000, 0x100,  1, 0x1000,       0, 0x0400, 127],
  'atxmega16c4' =>     [0x1E, 0x94, 0x43, 102, 0x50674,       0, 0x05000, 0x100,  1, 0x1000,       0, 0x0400, 127],
  'atxmega16d4' =>     [0x1E, 0x94, 0x42, 102, 0x50274,       0, 0x05000, 0x100,  1, 0x1000,       0, 0x0400,  91],
  'atxmega16e5' =>     [0x1E, 0x94, 0x45, 102, 0x50274,       0, 0x05000, 0x080,  1, 0x1000,       0, 0x0200,  43],
  'atxmega32c3' =>     [0x1E, 0x95, 0x49, 102, 0x50674,       0, 0x09000, 0x100,  1, 0x1000,       0, 0x0400, 127],
  'atxmega32d3' =>     [0x1E, 0x95, 0x4A, 102, 0x50274,       0, 0x09000, 0x100,  1, 0x1000,       0, 0x0400, 114],
  'atxmega32a4' =>     [0x1E, 0x95, 0x41, 102, 0x50274,       0, 0x09000, 0x100,  1, 0x1000,       0, 0x0400,  94],
  'atxmega32a4u' =>    [0x1E, 0x95, 0x41, 102, 0x50674,       0, 0x09000, 0x100,  1, 0x1000,       0, 0x0400, 127],
  'atxmega32c4' =>     [0x1E, 0x95, 0x44, 102, 0x50674,       0, 0x09000, 0x100,  1, 0x1000,       0, 0x0400, 127],
  'atxmega32d4' =>     [0x1E, 0x95, 0x42, 102, 0x50274,       0, 0x09000, 0x100,  1, 0x1000,       0, 0x0400,  91],
  'atxmega32e5' =>     [0x1E, 0x95, 0x4C, 102, 0x50274,       0, 0x09000, 0x080,  1, 0x1000,       0, 0x0400,  43],
  'atxmega64a1' =>     [0x1E, 0x96, 0x4E, 105, 0x5f3f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 125],
  'atxmega64a1u' =>    [0x1E, 0x96, 0x4E, 105, 0x5f7f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 127],
  'atxmega64b1' =>     [0x1E, 0x96, 0x52, 104, 0x587f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800,  81],
  'atxmega64a3' =>     [0x1E, 0x96, 0x42, 104, 0x583f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 122],
  'atxmega64a3u' =>    [0x1E, 0x96, 0x42, 104, 0x587f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 127],
  'atxmega64b3' =>     [0x1E, 0x96, 0x51, 104, 0x587f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800,  54],
  'atxmega64c3' =>     [0x1E, 0x96, 0x49, 104, 0x587f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 127],
  'atxmega64d3' =>     [0x1E, 0x96, 0x4A, 104, 0x583f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 114],
  'atxmega64a4u' =>    [0x1E, 0x96, 0x46, 104, 0x587f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800, 127],
  'atxmega64d4' =>     [0x1E, 0x96, 0x47, 104, 0x583f4,       0, 0x11000, 0x100,  1, 0x1000,       0, 0x0800,  91],
  'atxmega128a1' =>    [0x1E, 0x97, 0x4C, 107, 0x5fbfc,       0, 0x22000, 0x200,  1, 0x2000,       0, 0x0800, 125],
  'atxmega128a1u' =>   [0x1E, 0x97, 0x4C, 107, 0x5fffc,       0, 0x22000, 0x200,  1, 0x2000,       0, 0x0800, 127],
  'atxmega128b1' =>    [0x1E, 0x97, 0x4D, 106, 0x58ffc,       0, 0x22000, 0x100,  1, 0x2000,       0, 0x0800,  81],
  'atxmega128a3' =>    [0x1E, 0x97, 0x42, 106, 0x58bfc,       0, 0x22000, 0x200,  1, 0x2000,       0, 0x0800, 122],
  'atxmega128a3u' =>   [0x1E, 0x97, 0x42, 106, 0x58ffc,       0, 0x22000, 0x200,  1, 0x2000,       0, 0x0800, 127],
  'atxmega128b3' =>    [0x1E, 0x97, 0x4B, 106, 0x58ffc,       0, 0x22000, 0x100,  1, 0x2000,       0, 0x0800,  54],
  'atxmega128c3' =>    [0x1E, 0x97, 0x52, 106, 0x58ffc,       0, 0x22000, 0x200,  1, 0x2000,       0, 0x0800, 127],
  'atxmega128d3' =>    [0x1E, 0x97, 0x48, 106, 0x58bfc,       0, 0x22000, 0x200,  1, 0x2000,       0, 0x0800, 114],
  'atxmega128a4u' =>   [0x1E, 0x97, 0x46, 107, 0x5fffc,       0, 0x22000, 0x100,  1, 0x2000,       0, 0x0800, 127],
  'atxmega128d4' =>    [0x1E, 0x97, 0x47, 106, 0x58bfc,       0, 0x22000, 0x100,  1, 0x2000,       0, 0x0800,  91],
  'atxmega192a3' =>    [0x1E, 0x97, 0x44, 106, 0x58bfc,       0, 0x32000, 0x200,  1, 0x2000,       0, 0x0800, 122],
  'atxmega192a3u' =>   [0x1E, 0x97, 0x44, 106, 0x58ffc,       0, 0x32000, 0x200,  1, 0x2000,       0, 0x0800, 127],
  'atxmega192c3' =>    [0x1E, 0x97, 0x51, 106, 0x58ffc,       0, 0x32000, 0x200,  1, 0x2000,       0, 0x0800, 127],
  'atxmega192d3' =>    [0x1E, 0x97, 0x49, 106, 0x58bfc,       0, 0x32000, 0x200,  1, 0x2000,       0, 0x0800, 114],
  'atxmega256a3' =>    [0x1E, 0x98, 0x42, 106, 0x58bfc,       0, 0x42000, 0x200,  1, 0x2000,       0, 0x1000, 122],
  'atxmega256a3b' =>   [0x1E, 0x98, 0x43, 106, 0x58bfc,       0, 0x42000, 0x200,  1, 0x2000,       0, 0x1000, 122],
  'atxmega256a3bu' =>  [0x1E, 0x98, 0x43, 106, 0x58bfc,       0, 0x42000, 0x200,  1, 0x2000,       0, 0x1000, 127],
  'atxmega256a3u' =>   [0x1E, 0x98, 0x42, 106, 0x58ffc,       0, 0x42000, 0x200,  1, 0x2000,       0, 0x1000, 127],
  'atxmega256c3' =>    [0x1E, 0x98, 0x46, 106, 0x58ffc,       0, 0x42000, 0x200,  1, 0x2000,       0, 0x1000, 127],
  'atxmega256d3' =>    [0x1E, 0x98, 0x44, 106, 0x58bfc,       0, 0x42000, 0x200,  1, 0x2000,       0, 0x1000, 114],
  'atxmega384c3' =>    [0x1E, 0x98, 0x45, 106, 0x58ffc,       0, 0x62000, 0x200,  1, 0x2000,       0, 0x1000, 127],
  'atxmega384d3' =>    [0x1E, 0x98, 0x47, 106, 0x58bfc,       0, 0x62000, 0x200,  1, 0x2000,       0, 0x1000, 114],
  'attiny202' =>       [0x1E, 0x91, 0x23, 103, 0x50074,       0, 0x00800, 0x040,  1,      0, 0x01400, 0x0040,  26],
  'attiny204' =>       [0x1E, 0x91, 0x22, 103, 0x50074,       0, 0x00800, 0x040,  1,      0, 0x01400, 0x0040,  26],
  'attiny212' =>       [0x1E, 0x91, 0x21, 103, 0x50074,       0, 0x00800, 0x040,  1,      0, 0x01400, 0x0040,  26],
  'attiny214' =>       [0x1E, 0x91, 0x20, 103, 0x50074,       0, 0x00800, 0x040,  1,      0, 0x01400, 0x0040,  26],
  'attiny402' =>       [0x1E, 0x92, 0x27, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny404' =>       [0x1E, 0x92, 0x26, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny406' =>       [0x1E, 0x92, 0x25, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny412' =>       [0x1E, 0x92, 0x23, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny414' =>       [0x1E, 0x92, 0x22, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny416' =>       [0x1E, 0x92, 0x21, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny417' =>       [0x1E, 0x92, 0x20, 103, 0x50074,       0, 0x01000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny804' =>       [0x1E, 0x93, 0x25, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0080,  31],
  'attiny806' =>       [0x1E, 0x93, 0x24, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0080,  31],
  'attiny807' =>       [0x1E, 0x93, 0x23, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0080,  31],
  'attiny814' =>       [0x1E, 0x93, 0x22, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny816' =>       [0x1E, 0x93, 0x21, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny817' =>       [0x1E, 0x93, 0x20, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0080,  26],
  'attiny1604' =>      [0x1E, 0x94, 0x25, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  31],
  'attiny1606' =>      [0x1E, 0x94, 0x24, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  31],
  'attiny1607' =>      [0x1E, 0x94, 0x23, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  31],
  'attiny1614' =>      [0x1E, 0x94, 0x22, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  31],
  'attiny1616' =>      [0x1E, 0x94, 0x21, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  31],
  'attiny1617' =>      [0x1E, 0x94, 0x20, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  31],
  'attiny3214' =>      [0x1E, 0x95, 0x20, 103, 0x50274,       0, 0x08000, 0x080,  1,      0, 0x01400, 0x0100,  31],
  'attiny3216' =>      [0x1E, 0x95, 0x21, 103, 0x50274,       0, 0x08000, 0x080,  1,      0, 0x01400, 0x0100,  31],
  'attiny3217' =>      [0x1E, 0x95, 0x22, 103, 0x50274,       0, 0x08000, 0x080,  1,      0, 0x01400, 0x0100,  31],
  'atmega808' =>       [0x1E, 0x93, 0x26, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0100,  36],
  'atmega809' =>       [0x1E, 0x93, 0x2A, 103, 0x50074,       0, 0x02000, 0x040,  1,      0, 0x01400, 0x0100,  40],
  'atmega1608' =>      [0x1E, 0x94, 0x27, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  36],
  'atmega1609' =>      [0x1E, 0x94, 0x26, 103, 0x50274,       0, 0x04000, 0x040,  1,      0, 0x01400, 0x0100,  40],
  'atmega3208' =>      [0x1E, 0x95, 0x30, 103, 0x50274,       0, 0x08000, 0x080,  1,      0, 0x01400, 0x0100,  36],
  'atmega3209' =>      [0x1E, 0x95, 0x31, 103, 0x50274,       0, 0x08000, 0x080,  1,      0, 0x01400, 0x0100,  40],
  'atmega4808' =>      [0x1E, 0x96, 0x50, 103, 0x50274,       0, 0x0c000, 0x080,  1,      0, 0x01400, 0x0100,  36],
  'atmega4809' =>      [0x1E, 0x96, 0x51, 103, 0x50274,       0, 0x0c000, 0x080,  1,      0, 0x01400, 0x0100,  40],
);

my %unsupported = (
  # ATtiny4 ATtiny5 ATtiny9 ATtiny10 ATtiny20 ATtiny40 ATtiny102 ATtiny104
  'AVRtiny core' => [(grep { $uP{$_}->[_features] & F_TINY } keys %uP), 'attiny102', 'attiny104'],

  # AT90S1200 ATtiny11 ATtiny12 ATtiny15 ATtiny28
  'Minimal AVR1 core' => [grep { $uP{$_}->[_features] & F_ASM_ONLY } keys %uP],

  # ATtiny22 ATtiny26 AT90S2313 AT90S2323 AT90S2333 AT90S2343 AT90S4414 AT90S4433 AT90S4434 AT90S8515 AT90C8534 AT90S8535
  'AVR2 core without spm instruction' => [grep { !($uP{$_}->[_features] & F_HAVE_MOVW) && $uP{$_}->[_archnum] =~ /^2/ } keys %uP],

  # ATmega103 AT43USB320 AT43USB355 AT76C711 (ATmega603)
  'AVR3 core without smp instruction' => [grep { !($uP{$_}->[_features] & F_HAVE_MOVW) && $uP{$_}->[_archnum] =~ /^3/ } keys %uP],
);

my $slack = -4;

die "$Usage\nno unique .elf argument?\n" if 1 != grep { /^[^-].*elf$/ } @ARGV;
die "no architecture -mmcu=... argument?\n" if 1 != grep { /^-mmcu/ } @ARGV;

my $elf = (grep { /^[^-].*elf$/ } @ARGV)[0];
my $mcu = (grep { /^-mmcu=/ } @ARGV)[0];
$mcu =~ s/-mmcu=//;
my $novbl = !grep { /^-DVBL=/ } @ARGV;


for my $reason (keys %unsupported) {
  die "$progname: $mcu not supported ($reason)\n"
    if grep { lc $mcu eq lc $_ } @{$unsupported{$reason}};
}

# # make mcu name lower case, so that user can specify mcu regardless of case
# $uP{lc $_} = delete $uP{$_} for keys %uP;

die "$progname: mcu architecture $mcu unknown; use one of ". join(", ", keys %uP)."\n" if !exists $uP{lc $mcu};

# placement parameters are [start addr of bootloader, start addr of version section, rjmp opcode,  whether mcu has boot section]
my (@placement, $nowparams, @injectparams, $runs, $lastcmd, $lasterr, $addavailable, $converged);

$runs = 10; # max number of runs
$lastcmd = "";
$lasterr = "";
$nowparams = getplacement($mcu, $elf);
$addavailable = 0;
$converged = 0;
do {
  @injectparams = (
    sprintf("-DSTART=0x%xUL", $nowparams->[0]),
    sprintf("-DRJMPWP=0x%4x", $nowparams->[2]),
    sprintf("-Wl,--section-start=.text=0x%x", $nowparams->[0]),
    sprintf("-Wl,--section-start=.version=0x%x", $nowparams->[1])
  );

  # Add vbl compile option if uP does not support boot section
  push @injectparams, "-DVBL=1" if !$nowparams->[4] && $novbl;

  # Add number of available bytes once compilation has converged
  push @injectparams, "-D_urboot_AVAILABLE=$nowparams->[5]" if defined($nowparams->[5]) && $nowparams->[5] > 0 && $addavailable > 0;

  $lastcmd = join(' ', "${avrbins}avr-gcc", @injectparams, @ARGV);
  my ($stdout, $exit) = capture_merged {
    system("${avrbins}avr-gcc", @injectparams, @ARGV);
  };

  my $overlaps = 0;
  my @lines= split "\n", $stdout;
  $lasterr = "";
  foreach my $line (@lines) {
    $overlaps = 1 if $line =~ /overlaps section/;
    $lasterr .= "$line\n" if
      $line !~ /warning: call-clobbered register used for global register variable/ &&
      $line !~ /register uint16_t zaddress asm..r30..;/ &&
      $line !~ /^ *\^[~ ]*$/ &&
      $line !~ /: warning: #warning /;
  }

  # did the linker throw an error because of an overlap of .text and .version sections? increase slack;
  $slack += 2 if $exit && $overlaps;
  # any other error: exit
  if($exit && !$overlaps) {
    print "$lastcmd\n$lasterr";
    exit($exit);
  }

  @placement = @$nowparams;
  $nowparams = getplacement($mcu, $elf);
  $converged = $nowparams->[0] == $placement[0] && $nowparams->[1] == $placement[1] && $nowparams->[2] == $placement[2] && $nowparams->[3] == $placement[3];
  if($addavailable > 0) {
    $addavailable = -1;         # Beyond last avr-gcc call with -DUB_AVAILABLE=...; stop now
  } elsif(!$addavailable && $converged) {
    $addavailable = 1;
  }
} while(--$runs && (!$converged || $addavailable >= 0));

print "$lastcmd\n$lasterr";

exit(0);

# return [start addr of bootloader, start addr of version section, rjmp opcode, size of version section, whether mcu has boot section]
#

sub getplacement {
  my ($mcu, $elf) = @_;

  my ($bootstart, $pgmwriteoffset, $unused, $majorv, $minorv, $caps, $rjmpcode, $extended, $vsize);

  # copy needed properties from table above
  my ($pagesz, $flashsz, $mcubootsz) = @{$uP{lc $mcu}}[(_pagesz, _flashsz, _bootsz)];
  my ($bootsz, $hasboot) = ($mcubootsz, $mcubootsz > 0);

  # lex ATtiny28
  $pagesz = 1 if $pagesz < 1;

  # No .elf file?  create a "fake" entry this time round, hope file will exist next time for better estimate
  if(! -r $elf) {
    # try plenty of space and have a "typical" START
    $bootsz = 1024; # int((0x580+$pagesz-1)/$pagesz)*$pagesz;
    $bootstart = $flashsz-$bootsz;
    $pgmwriteoffset = $bootsz-4;  # creates an artificial endless loop as placeholder
    $vsize = 6;
    goto fake;
  }

  ($pgmwriteoffset, $unused) = getpgmwriteoffset($elf);
  ($majorv, $minorv, $caps, $rjmpcode, $extended, $vsize) = getversion16($elf);

  # examine size of bootloader, add slack and align to mcu's page size
  my $size = int((getsize($elf)+$slack + $pagesz-1)/$pagesz)*$pagesz;

  die "page aligned boot loader size is implausible ($size)\n" if $size < 32;

  # vector bootloader: mcu w/o bootloader section or version capability of bootloader says so
  my $vbl = !$hasboot || (defined($caps) && ($caps & UR_VBLMASK) != 0);

  if($vbl) {
    # "boot size" is flexible - chose actual size
    $bootsz = $size;
  } else {
    # boot size is encoded in fuses and a multiple of 1, 2, 4 or 8 of $bootsz - choose smallest
    die "Uuuhoh: bootsz entry in muc table is implausible ($bootsz)\n" if $bootsz < 32;
    while($size > $bootsz) {
      $bootsz *= 2;
    }
  }
  $bootstart = $flashsz - $bootsz;

  fake:
  my $rjmpwp = ((defined($pgmwriteoffset)? $pgmwriteoffset: $bootsz-4)-$bootsz+2)/2 & 0xfff;

  return [$bootstart, $bootstart+$bootsz-$vsize, 0xc000 + $rjmpwp, $vsize, $hasboot, $unused];
}

# return the size of the executable elf file
#
sub getsize {
  my $elf = shift;
  my $ret;

  open(my $in, "${avrbins}avr-size $elf |") or die "$progname: cannot pipe size from avr-size $elf (stopped)\n";

  while(<$in>) {
    chomp;
    my @col = split;
    if($col[-1] eq $elf) {
      printf STDERR "Warning: avr-size reports non-empty data section for $elf. Is this a bootloader?" if $col[1] ne "0" || $col[2] ne "0";
      $ret = 0+$col[0];
      last;
    }
  }
  close $in;
  die "failed to identify size of $elf with ${avrbins}avr-size\n" if !defined($ret);

  return $ret;
}



# return (distance between pgm_write_page() and main() in byte, number of unused bytes)
#
sub getpgmwriteoffset {
  my $elf = shift;
  my (%addr, $distmainpgm, $unused);

  open(my $in, "${avrbins}avr-nm -g $elf |") or die "$progname: cannot pipe size from ${avrbins}avr-nm -g $elf (stopped)\n";

  while(<$in>) {
    chomp;
    my @col = split;
    for my $sym (qw(main pgm_write_page urboot_version __data_load_end)) {
      $addr{$sym} = hex($col[0]) if @col > 2 && $col[2] eq "$sym";
    }
  }
  close $in;

  $distmainpgm = defined($addr{main}) && defined($addr{pgm_write_page})? $addr{pgm_write_page} - $addr{main}: undef;
  $unused = defined($addr{__data_load_end}) && defined($addr{urboot_version})? $addr{urboot_version}-$addr{__data_load_end}: undef;

  return ($distmainpgm, $unused);
}


# return version, capabilities and size of version section
#
sub getversion16 {
  my $elf = shift;
  my ($majorv, $minorv, $caps, $rjmpcode, $extended, $vsize) = (0, 0, 0, 0, 0, 0);

  # .version section of elf file can be 2, 4 or 6 bytes long (below an example with 6 bytes)
  open(my $in, "${avrbins}avr-readelf -x .version $elf |") or die "$progname: cannot pipe size from ${avrbins}avr-readelf $elf (stopped)\n";
  # Hex dump of section '.version':
  #   0x00007f3fa 7f05ffcf c33c                       .....<
  # or
  #   0x00007ffc c6cfc33a                            ...:
  # or
  #   0x00007ffe c33a                                ...:

  while(<$in>) {
    chomp;
    if(s/^ *0x[0-9a-f]{8,8} //i) {
      # determine how many bytes the dump of .vsection shows
      $vsize = /^[0-9a-f]{4,4} /i? 2:
               /^[0-9a-f]{8,8} [0-9a-f]{4,4} /i? 6:
               4;

      my $ver16 = extract16($_, $vsize == 2? 0: $vsize == 6? 9: 4);

      ($majorv, $minorv, $caps) = majmincap($ver16);
      $rjmpcode = extract16($_, $vsize == 6? 4: 0) if defined($caps) && ($caps && UR_PGMWRITEPAGE);
      $extended = extract16($_, 0) if $majorv > 7 || ($majorv == 7 && $minorv > 4);
      last;
    }
  }
  close $in;
#  die "failed to read two-byte number in section .version of $elf with ${avrbins}avr-readelf\n" if !defined($vsize);

  return ($majorv, $minorv, $caps, $rjmpcode, $extended, $vsize);
}


# extract major version number, minor version number and capabilities from 16-bit version
sub majmincap {
  my $ver16 = shift;

  return (0, 0, undef) if $ver16 == 0xffff || $ver16 < 4*256+1;
  return ($ver16>>8, $ver16 & 0xff, undef) if int($ver16/256) < 7*8+2;
  return ($ver16>>11, ($ver16>>8)&7, $ver16 & 0xff);
}

# extract 16-bit unsigned integer from hexdump line at position $off
sub extract16 {
  my ($str, $off) = @_;

  return 256*hex(substr($str, $off+2, 2)) + hex(substr($str, $off, 2));
}

# remove . from version numbers
sub getnum {
  my $v = shift;
  $v =~ tr/.//d;
  return $v;
}

